if t == 1
    EKF_x = zeros(6,nCars,nSimulations,nTicks);
    EKF_P = zeros(6,6,nCars,nSimulations,nTicks);
else
    
    % Predict Step at 400 Hz
    if mod(t, 3) == 0
        
        err = dot(normrnd(0, 1, [nSims, 3*3*nCars]),...
            reshape(repmat([imu_acc_err, imu_gyr_err, imu_mag_err]',[3,nCars]),1,[])',1);
        
        
    accel = normrnd([   obj.accel, obj.vel^2 / obj.wb * tan(obj.delta),0],...
                        obj.imu_acc_err);
    gyro  = normrnd([0,0,obj.vel*tan(obj.delta)/obj.wb], obj.imu_gyr_err);
    mag   = normrnd([0,0,obj.theta],                     obj.imu_mag_err);
        
        [accel, gyro, mag] = obj.sense_imu();
    
        theta = obj.ekf_x(3);

        R = [   cos(theta + pi/2), -sin(theta + pi/2),  0;...
                sin(theta + pi/2),  cos(theta + pi/2),  0;...
                0,                  0,                  1];

        accel_r = R * accel';

        obj.ekf_x = [...
                    obj.ekf_x(1) + obj.ekf_x(4) * dt + accel_r(1) / 2 * dt^2;...
                    obj.ekf_x(2) + obj.ekf_x(5) * dt + accel_r(2) / 2 * dt^2;...
                   (obj.ekf_x(3) + gyro(3)  * dt) * 0.98 + 0.02 * mag(3);...
                    obj.ekf_x(4) + accel_r(1) * dt;...
                    obj.ekf_x(5) + accel_r(2) * dt;...
                    gyro(3)];

        Q = diag([  obj.imu_acc_err/2/obj.rate_imu^2    ;...
                    obj.imu_acc_err/2/obj.rate_imu^2    ;...
                    obj.imu_gyr_err/obj.rate_imu        ;...
                    obj.imu_acc_err/obj.rate_imu        ;...
                    obj.imu_acc_err/obj.rate_imu        ;...
                    obj.imu_gyr_err]);

        F = [   1, 0, 0, dt, 0, 0;...
                0, 1, 0, 0, dt, 0;...
                0, 0, 1, 0, 0, dt;...
                0, 0, 0, 1, 0, 0;...
                0, 0, 0, 0, 1, 0;...
                0, 0, 0, 0, 0, 1];

        obj.ekf_cov = F * obj.ekf_cov * F' + Q;

        
        
        
    end

    % Pacmod Step at 30 Hz
    if mod(t, 40) == 0

    end

    % GPS step at 10 Hz
    if mod(t, 120) == 0

    end

    % UWB step at 3 Hz
    if mod(t, 400) == 0

    end
end


function [obj] = predict(obj)
    dt = 1/obj.rate_imu;
    [accel, gyro, mag] = obj.sense_imu();
    
    theta = obj.ekf_x(3);
    
    R = [   cos(theta + pi/2), -sin(theta + pi/2),  0;...
            sin(theta + pi/2),  cos(theta + pi/2),  0;...
            0,                  0,                  1];

    accel_r = R * accel';

    obj.ekf_x = [...
                obj.ekf_x(1) + obj.ekf_x(4) * dt + accel_r(1) / 2 * dt^2;...
                obj.ekf_x(2) + obj.ekf_x(5) * dt + accel_r(2) / 2 * dt^2;...
               (obj.ekf_x(3) + gyro(3)  * dt) * 0.98 + 0.02 * mag(3);...
                obj.ekf_x(4) + accel_r(1) * dt;...
                obj.ekf_x(5) + accel_r(2) * dt;...
                gyro(3)];

    Q = diag([  obj.imu_acc_err/2/obj.rate_imu^2    ;...
                obj.imu_acc_err/2/obj.rate_imu^2    ;...
                obj.imu_gyr_err/obj.rate_imu        ;...
                obj.imu_acc_err/obj.rate_imu        ;...
                obj.imu_acc_err/obj.rate_imu        ;...
                obj.imu_gyr_err]);

    F = [   1, 0, 0, dt, 0, 0;...
            0, 1, 0, 0, dt, 0;...
            0, 0, 1, 0, 0, dt;...
            0, 0, 0, 1, 0, 0;...
            0, 0, 0, 0, 1, 0;...
            0, 0, 0, 0, 0, 1];

    obj.ekf_cov = F * obj.ekf_cov * F' + Q;

end
function [obj] = update_mdl(obj)

    [ vel, delta ] = obj.sense_model();

    z = [   vel;...
            vel*tan(delta)/obj.wb ];
    
    kf_vel = sqrt( obj.ekf_x(4)^2 + obj.ekf_x(5)^2 );
    
    H = [   0, 0, 0, obj.ekf_x(4) / kf_vel, obj.ekf_x(5) / kf_vel, 0;...
            0, 0, 0, 0, 0, 1];

    h = [kf_vel; obj.ekf_x(6)];
        
    r2 = diag([ obj.enc_err;...
                obj.str_err * vel / obj.wb]);

    K = obj.ekf_cov * H' / (H * obj.ekf_cov * H' + r2);

    obj.ekf_x   = obj.ekf_x + K*(z - h);
    obj.ekf_cov = (eye(6) - K*H) * obj.ekf_cov;
    
end
function [obj] = update_gps(obj)
    
    [ x, y, theta, vel ] = sense_gps(obj); 
    
    z = [   x;...
            y;...
            theta;...
            vel];

    kf_vel = sqrt( obj.ekf_x(4)^2 + obj.ekf_x(5)^2 );
    
    H = [   1, 0, 0, 0, 0, 0;...
            0, 1, 0, 0, 0, 0;...
            0, 0, 1, 0, 0, 0;...
            0, 0, 0, obj.ekf_x(4) / kf_vel, obj.ekf_x(5) / kf_vel, 0];
    
    h = [   obj.ekf_x(1:3);...
            kf_vel];
        
    R = diag([  obj.gps_cep;...
                obj.gps_cep;...
                obj.gps_her;...
                obj.gps_ver]);

    K = obj.ekf_cov * H' / (H * obj.ekf_cov * H' + R);

    obj.ekf_x = obj.ekf_x + K*(z - h);
    obj.ekf_cov = (eye(6) - K*H)*obj.ekf_cov;
    
end
